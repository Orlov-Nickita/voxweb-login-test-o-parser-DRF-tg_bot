# Описание проекта

Данный API, реализованный на базе DjangoRESTFramework, создан для парсинга сайта Ozon. Парсинг осуществляется с помощью 
дочерней от Selenium библиотеки undetected_chromedriver, далее данные добавляются в базу данных (в данном проекте 
реализована MySQL) и после завершения парсинга отправляется уведомление с телеграм бот. Через телеграм бот в свою 
очередь можно получить список последних добавленных товаров.
В общем и целом проект настроен так, чтобы работать через Docker, достаточно запустить docker compose файл, дождаться 
сборки образов и запустить контейнеры.

# Сложности работы проекта
У сайта OZON очень сильная защита от парсинга. У них регулярно (раз в сутки-двое) меняются именования классов, что 
ломает привязку парсинговой программ к HTML разметке. Для этого было решено вынести наименования классов в переменные
в файле loader.py (рядом с settings.py). Перед запуском кода необходимо вручную проверить соответствие указанных классов
тем, что присутствуют на сайте.
И необходимо также учитывать, что выделенные, например, разным цветом ценники могут иметь отличие в классе (на практике 
получалось, что это был последний класс в разметке), поэтому я советую не указывать все классы из разметки, а в таком 
случае указывать часть. Код написан так, чтобы искать не полное соответствие, а частичное присутствие.
Например, на сайте может быть так:

<image src="./for_readme/red.jpg" alt="Красный ценник">

```text
Красный цвет:
<div class="y2h h3y c3-a **c3-b7**"...></div>>
```
<image src="./for_readme/green.jpg" alt="Зеленый ценник">

```text
Зеленый цвет:
<div class="y2h h3y c3-a **c3-b6**"...></div>>
```

Вот эти переменные для наименования классов:
```python
PRODUCT_CARD_CLASS_DIV = ''
IMAGE_CLASS_IMG = ''
HREF_CLASS_A = ''
TITLE_CLASS_DIV = ''
TITLE_CLASS_DIV_SPAN = ''
PRICE_CLASS_DIV = ''
NEW_PRICE_CLASS_DIV_SPAN = ''
OLD_PRICE_CLASS_DIV_SPAN = ''
SALE_PRICE_CLASS_DIV_SPAN = ''
COUNT_CLASS_DIV = ''
COUNT_CLASS_DIV_SPAN = ''
RATING_CLASS_DIV = ''
RATING_CLASS_DIV_SPAN = ''
```

# Первичная настройка работы проекта, основанного на фреймворке Django + DjangoRESTFramework

## Контракт для API
Подробная документация по API расположена по адресу (проект при этом должен быть запущен):
```http request
    /api/docs/
```
Там же можно и проверить функциональность API

Если запуск происходит на удаленном сервере или на адресе отличном от localhost, необходимо в файле api_doc.yaml
внести правки в заголовке 
```text
host: 127.0.0.1:5000
```

## Телеграм бот
Перед запуском проекта необходимо иметь API-KEY созданного бота. Как его создать можно найти в интернете. Далее этот 
ключ надо вписать в файл .env
CHAT_ID указывать необязательно, он настраивается автоматически. Когда бот будет запущен и нажата команда /start, на 
бэкенд будет отправлен запрос и в переменную CHAT_ID в файле .env будет записан Ваш идентификатор. Таким образом 
произойдет регистрация бота в бэкенде для отправки уведомлений

## Запуск в рамках Docker контейнера
Первый запуск может занять около 3-5 минут ожидания.
И перед первым запуском желательно оставить настройку на тайм-аут на 20 секунд, этого хватит, чтобы база данных успела 
сформироваться и быть доступной для Django. Далее уже можно поставить на 10
```text
... /bin/sleep 20 && ...
```
В корневой директории расположен файл .env.template. Его нужно переименовать в .env, далее заполнить поля. Во время 
первого запуска MySQL создаст базу данных и пользователя с теми параметрами, которые будут указаны в файле .env, 
поэтому там могут быть любые данные.

Перед запуском также необходимо выполнить сборку статических файлов. Выполните команду в директории, где находится файл manage.py:
```commandline
python3 manage.py collectstatic (python3 - unix / python - windows)
```

Далее выполнить последовательно команды 
```commandline
docker compose build
docker compose up
```

Дождаться, когда все запуститься и войти в контейнер с Django, чтобы создать суперпользователя. Docker настроен так, что
после запуска контейнера осуществляются все миграции в БД. Поэтому нужные таблицы уже будут созданы в момент запуска 
контейнера
Итак, посредством команды 
```commandline
docker ps
```
смотрим ID действующей контейнера с Django и далее подключаемся к нему через команду, где bf5f07cb3611 - это нужный ID
```commandline
docker exec -it bf5f07cb3611 /bin/bash
```
Далее переходим в директорию с файлом manage.py и выполняем команду и следуем инструкции
```commandline
python manage.py createsuperuser
```

Если запуск компонентов (Django или tg-bot) будут запускаться отдельно на локальной машине не в рамках Docker, тогда уже
в этих папках надо заполнить свои отдельные файлы .env, но для Docker этого не нужно, для Docker нужен файл корне 
директории

## Просмотр базы данных из контейнера
Чтобы просмотреть базу данных MySQL в контейнере Docker, нужно подключиться к контейнеру и выполнить запросы к базе 
данных

```commandline
docker exec -it <имя или id контейнера_mysql> mysql -u <пользователь> -p
```
- <имя или id контейнера_mysql> -> можно посмотреть в docker ps
- <пользователь> -> значение в переменно DB_USER

Введите пароль, который указан в файле docker-compose.yml для переменной DB_PASSWORD
И далее:
```commandline
USE <db_name>; (из переменной DB_NAME)
SHOW TABLES;
```
